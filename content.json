{"meta":{"title":"Solooo","subtitle":"静坐常思己过，闲谈莫论人非","description":null,"author":"Eric","url":"http://www.solooo.net","root":"/"},"pages":[{"title":"","date":"2019-07-17T04:30:48.091Z","updated":"2019-07-17T04:30:48.091Z","comments":true,"path":"404.html","permalink":"http://www.solooo.net/404.html","excerpt":"","text":"Title"},{"title":"categories","date":"2017-08-14T11:51:41.000Z","updated":"2019-07-17T04:30:48.099Z","comments":true,"path":"categories/index.html","permalink":"http://www.solooo.net/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-08-14T11:49:28.000Z","updated":"2019-07-17T04:30:48.103Z","comments":true,"path":"tags/index.html","permalink":"http://www.solooo.net/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Git commit 规范化","slug":"Git-commit-规范化","date":"2020-02-25T05:54:39.000Z","updated":"2020-03-05T01:26:40.921Z","comments":true,"path":"2020/02/25/Git-commit-规范化/","link":"","permalink":"http://www.solooo.net/2020/02/25/Git-commit-规范化/","excerpt":"","text":"规范且有意义的提交记录，有助于追踪代码修改和查看历史记录现在支持以下九种类型（参考 Angular 规范的 commit message） 123456789101112feat: 新功能（feature）fix: 修补bugver: 版本号修改(version)docs: 文档（documentation）style: 格式（不影响代码运行的变动）refactor: 重构（即不是新增功能，也不是修改bug的代码变动）test: 增加测试chore: 构建过程或辅助工具的变动perf: 性能优化（performance）tmp: 临时提交（可用于非 master 分支）冒号之后有一个空格","categories":[{"name":"git","slug":"git","permalink":"http://www.solooo.net/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://www.solooo.net/tags/git/"}]},{"title":"Ubuntu解压zip中文乱码","slug":"Ubuntu解压zip中文乱码","date":"2019-08-21T01:04:04.000Z","updated":"2019-08-21T01:05:05.679Z","comments":true,"path":"2019/08/21/Ubuntu解压zip中文乱码/","link":"","permalink":"http://www.solooo.net/2019/08/21/Ubuntu解压zip中文乱码/","excerpt":"","text":"正常解压乱码时可使用以下命令参数： 1unzip -O CP936 xxx.zip # 用GBK, GB18030也可以","categories":[],"tags":[]},{"title":"git合并提交记录&vim列编辑","slug":"git合并提交记录-vim列编辑","date":"2019-07-17T05:57:38.000Z","updated":"2019-07-17T06:42:46.394Z","comments":true,"path":"2019/07/17/git合并提交记录-vim列编辑/","link":"","permalink":"http://www.solooo.net/2019/07/17/git合并提交记录-vim列编辑/","excerpt":"查看日志提交记录 123456789101112131415161718192021222324$ git logcommit 93c290851b3baebd612885ea5b866311cdd913d0Author: solooo &lt;pjian108@gmail.com&gt;Date: Tue Mar 26 10:25:46 2019 +0800 add themescommit 6414ff9530f6006b65e2c765f675a88012402a82Author: solooo &lt;pjian108@gmail.com&gt;Date: Tue Mar 26 10:24:47 2019 +0800 updatecommit 6cf175fe84f28967416f896c7865945930857e78Author: solooo &lt;pjian108@gmail.com&gt;Date: Tue Mar 26 10:16:27 2019 +0800 updatecommit 22960dcfe9e2eab38aef77f002590ef2e39110fbAuthor: solooo &lt;pjian108@gmail.com&gt;Date: Mon Jan 28 15:41:47 2019 +0800 create","text":"查看日志提交记录 123456789101112131415161718192021222324$ git logcommit 93c290851b3baebd612885ea5b866311cdd913d0Author: solooo &lt;pjian108@gmail.com&gt;Date: Tue Mar 26 10:25:46 2019 +0800 add themescommit 6414ff9530f6006b65e2c765f675a88012402a82Author: solooo &lt;pjian108@gmail.com&gt;Date: Tue Mar 26 10:24:47 2019 +0800 updatecommit 6cf175fe84f28967416f896c7865945930857e78Author: solooo &lt;pjian108@gmail.com&gt;Date: Tue Mar 26 10:16:27 2019 +0800 updatecommit 22960dcfe9e2eab38aef77f002590ef2e39110fbAuthor: solooo &lt;pjian108@gmail.com&gt;Date: Mon Jan 28 15:41:47 2019 +0800 create 找到要合并的记录之前的一条commit id 122960dcfe 使用rebase命令合并 12345678910111213141516171819202122232425$ git rebase -i 22960dcfepick 6cf175f updatepick 6414ff9 updatepick 93c2908 add themespick 686983a updatepick 37553e5 upgrade dependency# Rebase 22960dc..37553e5 onto 22960dc (5 commands)## Commands:# p, pick = use commit# r, reword = use commit, but edit the commit message# e, edit = use commit, but stop for amending# s, squash = use commit, but meld into previous commit# f, fixup = like &quot;squash&quot;, but discard this commit&apos;s log message# x, exec = run command (the rest of the line) using shell# d, drop = remove commit## These lines can be re-ordered; they are executed from top to bottom.## If you remove a line here THAT COMMIT WILL BE LOST.## However, if you remove everything, the rebase will be aborted.## Note that empty commits are commented out vim 修改第一列的 pick 改为 fix 或 squash 具体区别下方有注释说明 vim 列编辑 1234ctrl+v 进入列模式方向键选择编辑的列内容shift+i 进入列编辑模式输入内容两次 Esc 保存编辑 shift+i 进入列编辑模式时，光标只在第一行有，双南 Esc 保存后整列会赋值 以上操作完成后，保存文件即可合并提交记录 切换不同分支合并代码时，看到的记录也只有一条","categories":[{"name":"git","slug":"git","permalink":"http://www.solooo.net/categories/git/"},{"name":"vim","slug":"git/vim","permalink":"http://www.solooo.net/categories/git/vim/"}],"tags":[{"name":"git","slug":"git","permalink":"http://www.solooo.net/tags/git/"}]},{"title":"菜单树形结构","slug":"菜单树形结构","date":"2019-03-26T02:29:28.000Z","updated":"2019-07-17T04:30:48.099Z","comments":true,"path":"2019/03/26/菜单树形结构/","link":"","permalink":"http://www.solooo.net/2019/03/26/菜单树形结构/","excerpt":"","text":"菜单树形结构拼装 12345678910111213141516171819/** * 创建层级 * @param menus * @return */private List&lt;Menu&gt; createTree(List&lt;Menu&gt; menus) &#123; List&lt;Menu&gt; result = new ArrayList&lt;&gt;(); for (Menu menu : menus) &#123; if (menu.getParentId() == null) &#123; result.add(menu); &#125; for (Menu m : menus) &#123; if (menu.getId().equals(m.getParentId())) &#123; menu.getChildren().add(m); &#125; &#125; &#125; return result;&#125;","categories":[{"name":"code","slug":"code","permalink":"http://www.solooo.net/categories/code/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.solooo.net/tags/java/"}]},{"title":"SpringBoot打jar包后中获取resource下的文件","slug":"SpringBoot打jar包后中获取resource下的文件","date":"2019-03-26T01:29:49.000Z","updated":"2019-07-17T04:30:48.095Z","comments":true,"path":"2019/03/26/SpringBoot打jar包后中获取resource下的文件/","link":"","permalink":"http://www.solooo.net/2019/03/26/SpringBoot打jar包后中获取resource下的文件/","excerpt":"","text":"jar 包中获取resource下的文件 12345String context = null;InputStream resourceAsStream = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"applicationEx.json\");if (resourceAsStream != null) &#123; context = IOUtils.toString(resourceAsStream);&#125;","categories":[{"name":"code","slug":"code","permalink":"http://www.solooo.net/categories/code/"}],"tags":[{"name":"code","slug":"code","permalink":"http://www.solooo.net/tags/code/"}]},{"title":"consul删除无效服务","slug":"consul删除无效服务","date":"2019-01-28T07:31:53.000Z","updated":"2019-07-17T04:30:48.099Z","comments":true,"path":"2019/01/28/consul删除无效服务/","link":"","permalink":"http://www.solooo.net/2019/01/28/consul删除无效服务/","excerpt":"","text":"微服务注册中心 consul 删除无效服务需要通过 api 发送请求，UI 页面未提供入口 1curl -X PUT http://localhost:8500/v1/agent/service/deregister/microservice-gateway-8000 其中 microservice-gateway-8000 为服务名称 删除无效节点 1curl -X PUT http://127.0.0.1:8500/v1/agent/force-leave/&#123;节点id&#125;","categories":[{"name":"linux","slug":"linux","permalink":"http://www.solooo.net/categories/linux/"}],"tags":[{"name":"consul","slug":"consul","permalink":"http://www.solooo.net/tags/consul/"}]},{"title":"ssh密钥登录远程服务器配置","slug":"ssh密钥登录远程服务器配置","date":"2019-01-28T06:04:25.000Z","updated":"2019-07-17T04:30:48.099Z","comments":true,"path":"2019/01/28/ssh密钥登录远程服务器配置/","link":"","permalink":"http://www.solooo.net/2019/01/28/ssh密钥登录远程服务器配置/","excerpt":"配置无密码登录远程服务器，本机 ubuntu18.04, 服务器 centos 首选确保远程服务器安装配置ssh服务，此处使用阿里云，默认安装此服务。以下所有命令均在本地执行 1、生成 ssh 公钥密钥文件命令： 1$ ssh-keygen","text":"配置无密码登录远程服务器，本机 ubuntu18.04, 服务器 centos 首选确保远程服务器安装配置ssh服务，此处使用阿里云，默认安装此服务。以下所有命令均在本地执行 1、生成 ssh 公钥密钥文件命令： 1$ ssh-keygen 根据提示输入文件名，或者使用默认文件名id_rsa，一路回车即可，待返回如下内容表示创建成功 1234567891011121314151617181920Generating public/private rsa key pair.Enter file in which to save the key (/home/eric/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /home/eric/.ssh/id_rsa.Your public key has been saved in /home/eric/.ssh/id_rsa.pub.The key fingerprint is:SHA256:F74RLcqlTC9Le9kzY9XjHppuVhjouDxRTESvzcF9ZWE eric@ericThe key's randomart image is:+---[RSA 2048]----+| .++oE=|| . + .o.|| . O + .|| + * O . . || S * = +..|| . = O +...|| o + O .o || . = *+ .|| . =+ . |+----[SHA256]-----+ 查看目录~/.ssh，生成如下两个文件（默认文件名）: 12id_rsaid_rsa.pub 2、上传公钥文件到服务器命令: 1ssh-copy-id username@hostname 其中 username 为远程服务器登录名， hostname 为远程服务器 IP 或域名 3、登录服务器经过以上配置后，本地即可免密码登录服务器 命令： 1ssh username@hostname 4、配置本地 ssh 记住连接地址每次输入用户名和 IP 比较麻烦，可在 Terminal 中配置好用户名和地址，使用别名登录，具体配置如下： 编辑（没有就新建一个）~/.ssh/config: 12345Host alias_name # 服务器别名HostName xx.xx.xxx.xxx # 服务器IP或域名User test # 服务器登录用户名Port 22 # ssh 登录端口IdentityFile ~/.ssh/id_rsa # 密钥文件，不需要后辍 保存后，可在 Terminal 中使用以下命令直接登录服务器： 1ssh alias_name 若有多个服务器，在 config 文件中继续添加一条配置即可，格式和内容与上一条相同","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.solooo.net/categories/Linux/"}],"tags":[{"name":"ssh","slug":"ssh","permalink":"http://www.solooo.net/tags/ssh/"}]},{"title":"SpringBoot 上传文件临时目录失效问题解决","slug":"SpringBoot-上传文件临时目录失效问题解决","date":"2018-08-21T06:48:28.000Z","updated":"2019-07-17T04:30:48.095Z","comments":true,"path":"2018/08/21/SpringBoot-上传文件临时目录失效问题解决/","link":"","permalink":"http://www.solooo.net/2018/08/21/SpringBoot-上传文件临时目录失效问题解决/","excerpt":"","text":"SpringBoot 上传文件时会创建临时目录暂存文件，但临时目录会被系统自动清理掉导致上传失败，解决办法之一就是修改默认的临时文件目录： SpringBoot 执行文件增加以下代码，自定义文件目录 12345678910111213141516171819/** * 文件上传临时目录修改 * @return */@BeanMultipartConfigElement multipartConfigElement() &#123; MultipartConfigFactory factory = new MultipartConfigFactory(); String tmpPath = rootPath + File.separator + \"tmp\"; Path path = Paths.get(tmpPath); if (!Files.exists(path) || !Files.isDirectory(path)) &#123; try &#123; Files.createDirectories(path); &#125; catch (IOException e) &#123; logger.error(\"tmp 目录创建失败! 请手动创建此目录：&#123;&#125;\", tmpPath); &#125; &#125; factory.setLocation(tmpPath); return factory.createMultipartConfig();&#125;","categories":[],"tags":[]},{"title":"Docker Registry https 部署","slug":"Docker-Registry-https-部署","date":"2018-07-05T04:44:04.000Z","updated":"2019-07-17T04:30:48.091Z","comments":true,"path":"2018/07/05/Docker-Registry-https-部署/","link":"","permalink":"http://www.solooo.net/2018/07/05/Docker-Registry-https-部署/","excerpt":"现在 Docker Registry 默认都启用 https 访问，虽然可以通过配置其他节点的 daemon.json 文件来使用 http 访问，但如此操作比较麻烦，且限制节点仓库地址。在部署 Kubernetes 时，必须要有一个可以方便访问的仓库，于是参考网络资料，尝试搭建带证书的私有仓库并记录过程如下","text":"现在 Docker Registry 默认都启用 https 访问，虽然可以通过配置其他节点的 daemon.json 文件来使用 http 访问，但如此操作比较麻烦，且限制节点仓库地址。在部署 Kubernetes 时，必须要有一个可以方便访问的仓库，于是参考网络资料，尝试搭建带证书的私有仓库并记录过程如下 openssl生成密钥文件 修改openssl配置文件，编辑/etc/pki/tls/openssl.cnf,在[ v3_ca ]下增加了一行：12[ v3_ca ]subjectAltName=IP:192.168.1.6 192.168.1.6就是 Registry 所在的宿主机 IP这个很重要，否则在后面会报registry endpoint…x509: cannot validate certificate for … because it doesn’t contain any IP SANs 生成密钥1openssl req -newkey rsa:4096 -nodes -sha256 -keyout certs/domain.key -x509 -days 365 -out certs/domain.crt 在证书的创建过程中，会询问国家、省分、城市、组织、部门和common name的信息，其中common name信息填写主机的IP 192.168.1.6 证书创建完毕后，在certs目录下出现了两个文件: 12domain.key # 证书文件domain.crt # 私钥文件 启动仓库加入证书 仓库启动命令 12345678910docker run -d \\ --restart=always \\ --name registry \\ -v /root/certs:/root/certs \\ -v /var/lib/registry:/var/lib/registry \\ -e REGISTRY_HTTP_ADDR=0.0.0.0:5000 \\ -e REGISTRY_HTTP_TLS_CERTIFICATE=/root/certs/domain.cert \\ -e REGISTRY_HTTP_TLS_KEY=/root/certs/domain.key \\ -p 5000:5000 \\ registry 可在浏览器访问：https://192.168.1.6:5000/v2 测试仓库是否可用。正常会返回{} 其他主机使用仓库 将第三步生成的密钥文件复制到需要使用仓库的主机上 在其他主机上创建目录mkdir -p /etc/docker/certs.d/192.168.1.6:5000 目录中 IP 端口即仓库地址 1scp certs/domain.crt root@ht240:/etc/docker/certs.d/192.168.1.6:5000/ca.crt 无需重启docker服务即可使用私有仓库 仓库Web界面 Doceker Registry Webdocker-registry-web一个简单的仓库显示UI，只能显示不能做其他任何操作 12345docker run -d -p 9001:8080 --name registry-web \\ -e REGISTRY_URL=https://192.168.1.6:5000/v2 \\ -e REGISTRY_TRUST_ANY_SSL=true \\ -e REGISTRY_NAME=192.168.1.6:5000 \\ hyper/docker-registry-web","categories":[{"name":"technology","slug":"technology","permalink":"http://www.solooo.net/categories/technology/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://www.solooo.net/tags/docker/"}]},{"title":"Springboot AOP配置","slug":"Springboot-AOP配置","date":"2017-12-26T05:25:35.000Z","updated":"2019-07-17T04:30:48.095Z","comments":true,"path":"2017/12/26/Springboot-AOP配置/","link":"","permalink":"http://www.solooo.net/2017/12/26/Springboot-AOP配置/","excerpt":"Springboot 整合aop做日志拦截，配置很简单。 在pom.xml文件中引入aop相关的包 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt; aop类配置示例","text":"Springboot 整合aop做日志拦截，配置很简单。 在pom.xml文件中引入aop相关的包 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt; aop类配置示例 1234567891011121314151617181920212223242526272829303132@Aspect@Componentpublic class LogAspect &#123; private Logger logger = LoggerFactory.getLogger(LogAspect.class); @Pointcut(\"execution(* com.ht.yry.web.controller..*(..))\") public void executeService()&#123;&#125; @Before(\"executeService() &amp;&amp; @annotation(option)\") public void beforePoint(JoinPoint joinPoint, ApiOperation option) &#123; ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); HttpServletRequest request = attributes.getRequest(); //URL logger.info(\"url=&#123;&#125;\", request.getRequestURI()); //method logger.info(\"method=&#123;&#125;\", request.getMethod()); //ip logger.info(\"ip=&#123;&#125;\",request.getRemoteAddr()); //类方法 logger.info(\"class=&#123;&#125; and method name = &#123;&#125;\",joinPoint.getSignature().getDeclaringTypeName(),joinPoint.getSignature().getName()); //参数 logger.info(\"参数=&#123;&#125;\",joinPoint.getArgs(), joinPoint.getArgs()); logger.info(\"apiOption=&#123;&#125;\", option.value()); // 获取方法所在类上的Api注解，例 @Api(tags=\"文件管理\") Api annotation = AnnotationUtils .findAnnotation(joinPoint.getSignature().getDeclaringType(), Api.class); logger.info(\"api=&#123;&#125;\", String.join(\",\",annotation.tags())); &#125;&#125;","categories":[{"name":"technology","slug":"technology","permalink":"http://www.solooo.net/categories/technology/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.solooo.net/tags/java/"}]},{"title":"jdk8 日期时间处理","slug":"jdk8-日期时间处理","date":"2017-12-08T07:52:19.000Z","updated":"2019-07-17T04:30:48.099Z","comments":true,"path":"2017/12/08/jdk8-日期时间处理/","link":"","permalink":"http://www.solooo.net/2017/12/08/jdk8-日期时间处理/","excerpt":"jdk8更新了日期时间处理类。值得注意的是新增的时间处理方法更加方便使用，而且是线程安全的，包括日期的格式化，再也不用担心多线程下日期格式化的麻烦了！","text":"jdk8更新了日期时间处理类。值得注意的是新增的时间处理方法更加方便使用，而且是线程安全的，包括日期的格式化，再也不用担心多线程下日期格式化的麻烦了！ 直接上代码： 123456789101112131415161718192021222324252627282930// 当时日期时间System.out.println(\"LocalDate.now() = \" + LocalDate.now());System.out.println(\"LocalTime.now() = \" + LocalTime.now());System.out.println(\"LocalDateTime.now() = \" + LocalDateTime.now());System.out.println(\"Instant.now() = \" + Instant.ofEpochMilli(System.currentTimeMillis()));System.out.println(\"ZonedDateTime.now() = \" + ZonedDateTime.now().format(DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\")));// 字符串解析成日期System.out.println(\"Date parse 20170101 = \" + LocalDate.parse(\"20170101\", DateTimeFormatter.BASIC_ISO_DATE));System.out.println(\"Date parse 2017/01/01 = \" + LocalDate.parse(\"2017/01/01\", DateTimeFormatter.ofPattern(\"yyyy/MM/dd\")));// 日期格式化显示字符串System.out.println(\"Date to string = \" + LocalDateTime.now().format(DateTimeFormatter.BASIC_ISO_DATE));System.out.println(\"Date to string = \" + LocalDateTime.now().format(DateTimeFormatter.ofPattern(\"yyyy年MM月dd日 HH时mm分ss秒\")));/* * 按单位显示，相差 几个月几天 */Period period = Period.between(LocalDate.now(), LocalDate.of(2018, 1,7));System.out.println(String.format(\"相差时间：%s 年 %s 月 %s 天\" , period.getYears(), period.getMonths(), period.getDays()));/* * 相差多少天或者多少小时/分钟等 */Duration duration = Duration.between(LocalDateTime.now(), LocalDateTime.of(2018, 1, 7, 0, 0, 0));System.out.println(\"相差天数：\" + duration.toDays());System.out.println(\"相差分钟数：\" + duration.toMinutes());// 本月第一天System.out.println(\"本月第一天：\" + LocalDate.now().with(TemporalAdjusters.firstDayOfMonth())); 输出内容： 12345678910111213LocalDate.now() = 2017-12-08LocalTime.now() = 15:51:38.833LocalDateTime.now() = 2017-12-08T15:51:38.833Instant.now() = 2017-12-08T07:51:38.833ZZonedDateTime.now() = 2017-12-08 15:51:38Date parse 20170101 = 2017-01-01Date parse 2017/01/01 = 2017-01-01Date to string = 20171208Date to string = 2017年12月08日 15时51分38秒相差时间：0 年 0 月 30 天相差天数：29相差分钟数：42248本月第一天：2017-12-01","categories":[{"name":"technology","slug":"technology","permalink":"http://www.solooo.net/categories/technology/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.solooo.net/tags/java/"}]},{"title":"Docker  openjdk-8-jdk-alpine 容器时间与jdk时区不同修改方法","slug":"Docker-openjdk-8-jdk-alpine-容器时间与jdk时区不同修改方法","date":"2017-11-14T05:42:36.000Z","updated":"2019-07-17T04:30:48.091Z","comments":true,"path":"2017/11/14/Docker-openjdk-8-jdk-alpine-容器时间与jdk时区不同修改方法/","link":"","permalink":"http://www.solooo.net/2017/11/14/Docker-openjdk-8-jdk-alpine-容器时间与jdk时区不同修改方法/","excerpt":"","text":"测试时发现以 openjdk-8-jdk-alpine 为基础镜像制作的镜像有时区问题。查资料知道 alpine 本身不带时区信息。按以下方法修改后正常获取时间。 一、挂载宿主机的时区到容器启动命令增加参数 -v /etc/localtime:/etc/localtime 启动容器，进入查看时间正常，时区也已同步。但java应用获取的时间还是差8小时。 继续查找资料 java 获取时区与 linux 系统时区的不同 参考博客 二、设置容器内时区通过后来不断尝试，修改 localtime 确定无效，最后采用笨方法，制作应用镜像时，通过 shell 修改时区 Dockerfile 中增加修改时区的命令 echo &quot;Asia/Shanghai&quot; &gt; /etc/timezone 通过测试，jdk 中或正常获取设置的东8时区。但还有一个遗留问题，使用 springboot 启动项目，打印出来的时间时间还是默认时区，而应用中获取的时间都是正常的时间。暂且记下，有时间再细看","categories":[{"name":"technology","slug":"technology","permalink":"http://www.solooo.net/categories/technology/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://www.solooo.net/tags/docker/"}]},{"title":"CentOS7 DNS错误导致yum无法安装软件","slug":"CentOS7-DNS错误导致yum无法安装软件","date":"2017-09-19T03:52:48.000Z","updated":"2019-07-17T04:30:48.091Z","comments":true,"path":"2017/09/19/CentOS7-DNS错误导致yum无法安装软件/","link":"","permalink":"http://www.solooo.net/2017/09/19/CentOS7-DNS错误导致yum无法安装软件/","excerpt":"","text":"刚安装好的CentOS 7在安装vim时，提示以下错误：&quot;Could not resolve host: mirrorlist.centos.org; Unknown error&quot; 错误详细： 1234567891011121314151617181920212223242526272829303132[root@ht247 ~]# yum install -y vimLoaded plugins: fastestmirrorCould not retrieve mirrorlist http://mirrorlist.centos.org/?release=7&amp;arch=x86_64&amp;repo=os&amp;infra=stock error was14: curl#6 - &quot;Could not resolve host: mirrorlist.centos.org; Unknown error&quot; One of the configured repositories failed (Unknown), and yum doesn&apos;t have enough cached data to continue. At this point the only safe thing yum can do is fail. There are a few ways to work &quot;fix&quot; this: 1. Contact the upstream for the repository and get them to fix the problem. 2. Reconfigure the baseurl/etc. for the repository, to point to a working upstream. This is most often useful if you are using a newer distribution release than is supported by the repository (and the packages for the previous distribution release still work). 3. Disable the repository, so yum won&apos;t use it by default. Yum will then just ignore the repository until you permanently enable it again or use --enablerepo for temporary usage: yum-config-manager --disable &lt;repoid&gt; 4. Configure the failing repository to be skipped, if it is unavailable. Note that yum will try to contact the repo. when it runs most commands, so will have to try and fail each time (and thus. yum will be be much slower). If it is a very temporary problem though, this is often a nice compromise: yum-config-manager --save --setopt=&lt;repoid&gt;.skip_if_unavailable=trueCannot find a valid baseurl for repo: base/7/x86_64 网上找了原因：DNS配置错误导致无法连接到源。 解决方法：编辑/etc/resolv.conf，如果没有配置则添加以下内容 nameserver 8.8.8.8如果DNS已配，则查看防火墙配置，具体不没碰到，以后遇到再补充","categories":[{"name":"technology","slug":"technology","permalink":"http://www.solooo.net/categories/technology/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.solooo.net/tags/Linux/"}]},{"title":"Docker学习(二)-Dockerfile","slug":"Docker学习-二-Dockerfile","date":"2017-09-15T09:52:56.000Z","updated":"2019-07-17T04:30:48.091Z","comments":true,"path":"2017/09/15/Docker学习-二-Dockerfile/","link":"","permalink":"http://www.solooo.net/2017/09/15/Docker学习-二-Dockerfile/","excerpt":"介绍很多情况下我们需要自己制作镜像，打包自己的应用放到docker上执行。Dockerfile就是打包镜像的利器 制作Docker镜像有两种方式： 一、启动一个基础窗口，在其中进行定制化操作后，commit当前容器，则会将之前一系列操作保存到镜像； 二、使用Dockerfile创建镜像 第一种不建议使用，一般用来被入侵后保存现场等场景中。主要创建方式是通过Dockerfile方式 Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。","text":"介绍很多情况下我们需要自己制作镜像，打包自己的应用放到docker上执行。Dockerfile就是打包镜像的利器 制作Docker镜像有两种方式： 一、启动一个基础窗口，在其中进行定制化操作后，commit当前容器，则会将之前一系列操作保存到镜像； 二、使用Dockerfile创建镜像 第一种不建议使用，一般用来被入侵后保存现场等场景中。主要创建方式是通过Dockerfile方式 Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。 示例以定制JDK1.8镜像为例 首先，创建空目录myimg，在新目录中执行touch Dockerfile来创建空的Dockerfile文件，然后复制官网下载的jdk1.8安装包(jdk-8u144-linux-x64.tar.gz)到myimg中 编辑Docker内容如下： 123FROM centos:7ADD jdk-8u144-linux-x64.tar.gz /usr/java/ENV JRE_HOME=/usr/java/jdk1.8.0_144 逐行解释： 第1行：FROM指令指定镜像依赖的基础镜像，这里我用的官方的centos7镜像做为基础镜像。所有操作都在此镜像基础上进行 第2行：ADD指令作用为添加文件到镜像中，如果为压缩包，会自动解压；可以直接使用http链接，打包镜像时会自动下载文件 第3行：EVN指令作用为设置环境变量 在myimg目录中执行以下命令 1docker build -t myimg . 将看到制作过程，结束后可用docker images查看镜像列表，是否存在自制镜像 Dockerfile指令详解FROM格式 123FROM &lt;image&gt;orFROM &lt;image&gt;:&lt;tag&gt; 必须做为第一行，指定镜像基准。 COPY格式 123COPY &lt;源路径&gt;... &lt;目标路径&gt;orCOPY [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;] COPY 指令将从构建上下文目录中 &lt;源路径&gt; 的文件/目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置。例如： 1COPY start.sh /opt/ &lt;源路径&gt; 可以是多个，甚至可以是通配符； &lt;目标路径&gt; 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 WORKDIR 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。 此外，还需要注意一点，使用 COPY 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。 ADD格式与COPY一样，基本作用也相似，但功能比COPY强大 如果源路径是压缩包，上传后会自动解压。 源路径支持超链接，可从远程下载文件。但如果链接下载的是压缩包，不会自动解压，所以，不建议使用 此指令只建议需要上传本地压缩包并解压的时候使用，其他情况还是使用COPY比较好 RUN格式 123RUN &lt;命令/可执行文件&gt; # shell格式orRUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;] #exec格式 在当前镜像的顶层执行任何命令，并commit成新的镜像. RUN格式有两种写法。区别如下： shell格式，相当于执行/bin/sh -c &quot;&lt;command&gt;&quot;： exec格式，不会触发shell，所以$HOME这样的环境变量无法使用，但它可以在没有bash的镜像中执行，而且可以避免错误的解析命令字符串： Dockerfile每条指令都会创建新的层，所以当有多条命令需要执行时，尽量合并在一个RUN指令里。多条执行命令： 123456789101112RUN buildDeps=&apos;gcc libc6-dev make&apos; \\ &amp;&amp; apt-get update \\ &amp;&amp; apt-get install -y $buildDeps \\ &amp;&amp; wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot; \\ &amp;&amp; mkdir -p /usr/src/redis \\ &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \\ &amp;&amp; make -C /usr/src/redis \\ &amp;&amp; make -C /usr/src/redis install \\ &amp;&amp; rm -rf /var/lib/apt/lists/* \\ &amp;&amp; rm redis.tar.gz \\ &amp;&amp; rm -r /usr/src/redis \\ &amp;&amp; apt-get purge -y --auto-remove $buildDeps CMD格式与RUN相同，也区分shell和exec两种格式 用于指定默认的容器主进程的启动命令的 在指令格式上，一般推荐使用 exec 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 “，而不要使用单引号 容器中应用在前台执行和后台执行的问题: Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 upstart/systemd 去启动后台服务，容器内没有后台服务的概念。 一些初学者将 CMD 写为：CMD service nginx start 然后发现容器执行后就立即退出了。甚至在容器内去使用 systemctl 命令结果却发现根本执行不了。这就是因为没有搞明白前台、后台的概念，没有区分容器和虚拟机的差异，依旧在以传统虚拟机的角度去理解容器。 对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。 ENV格式 12ENV &lt;key&gt; &lt;value&gt;ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;... 作用是设置环境变量。无论是后面的其它指令，如 RUN，还是运行时的应用，都可以直接使用这里定义的环境变量","categories":[{"name":"technology","slug":"technology","permalink":"http://www.solooo.net/categories/technology/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://www.solooo.net/tags/docker/"}]},{"title":"Docker学习(一)","slug":"Docker学习-一","date":"2017-09-15T03:49:04.000Z","updated":"2019-07-17T04:30:48.091Z","comments":true,"path":"2017/09/15/Docker学习-一/","link":"","permalink":"http://www.solooo.net/2017/09/15/Docker学习-一/","excerpt":"docker学习笔记 安装Docker安装参考阿里云国内镜像安装，比用官方国外速度快很多。 阿里云提供自动安装脚本可以很方便安装docker,shell 中执行以下命令： curl -sSL http://acs-public-mirror.oss-cn-hangzhou.aliyuncs.com/docker-engine/internet | sh -参考地址：Docker CE 镜像源站 文档写的很清楚，具体不再详述","text":"docker学习笔记 安装Docker安装参考阿里云国内镜像安装，比用官方国外速度快很多。 阿里云提供自动安装脚本可以很方便安装docker,shell 中执行以下命令： curl -sSL http://acs-public-mirror.oss-cn-hangzhou.aliyuncs.com/docker-engine/internet | sh -参考地址：Docker CE 镜像源站 文档写的很清楚，具体不再详述 Docker国内镜像加速器国内访问Docker Hub速度很慢，推荐使用国内的镜像加速器。国内提供镜像加速器的服务有很多，我用的阿里云加速器 如何使用Docker加速器 针对Docker客户端版本大于1.10的用户 可以通过修改daemon配置文件/etc/docker/daemon.json来使用加速器，阿里云镜像加速地址每个用户都不相同，登录后可查看： 12345678sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'&#123; \"registry-mirrors\": [\"https://xxxx.mirror.aliyuncs.com\"]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker 常用命令镜像、容器 1234567891011121314151617181920## 显示docker镜像docker images## 删除docker镜像docker rmi -f [imageid]## 停止docker容器docker stop [containerId]## 删除docker容器docker rm -f [containerId]## 显示docker容器docker ps -a 列出所有容器,含已停止运行容器 -f [exited=&lt;int&gt;] 列出满足 exited=&lt;int&gt; 条件的容器 -l 仅列出最新创建的一个容器 -q 仅列出容器ID -s 显示容器大小 -n=4 列出最近创建的4个容器 --no-trunc 显示完整的容器ID --before=\"nginx\" 列出在某一容器之前创建的容器, 接受容器名称和ID作为参数 --since=\"nginx\" 列出在某一容器之后创建的容器, 接受容器名称和ID作为参数 启动： 123456789docker run [imageId] -it : -i 表示交互; -t 表示终端; 合起来就是交互式终端 -d : 后台运行 -p : 默认桥接网络模式, 映射端口 -v : 挂载容器和主机间的路径 --rm : 容器停止后删除容器 --net=host : 网络主机模式 --restart=always : 随着docker服务开机启动 --link=&#123;containerName&#125;:myhost : 在容器中建立另一个容器containerName连接,myhost代替连接地址或IP 上传下载 1234567##下载docker pull [ip]:[port]/tomcat:8##上传##打版本docker tag tomcat:8 [ip]:[port]/tomcat:8##上传docker push [ip]:[port]/tomcat:8 其它命令 123456789101112131415161718192021## 进入容器docker exec [containerId] -it bash## 执行命令docker exec [containerId] -it [command]## 容器控制台日志docker logs -f [containerId]###清理####杀死所有正在运行的容器docker kill $(docker ps -a -q)#删除所有已经停止的容器docker rm $(docker ps -a -q)#删除所有未打 dangling 标签的镜像docker rmi $(docker images -q -f dangling=true)#删除所有镜像docker rmi $(docker images -q)","categories":[{"name":"technology","slug":"technology","permalink":"http://www.solooo.net/categories/technology/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://www.solooo.net/tags/docker/"}]},{"title":"maven3自定义archetype","slug":"maven3自定义archetype","date":"2017-08-14T11:13:28.000Z","updated":"2019-07-17T04:30:48.099Z","comments":true,"path":"2017/08/14/maven3自定义archetype/","link":"","permalink":"http://www.solooo.net/2017/08/14/maven3自定义archetype/","excerpt":"maven使用起来还是很方便，但默认自带的archetype配置junit版本比较老。每次创建新项目都要手动修改junit版本，所以就想着能不能自己建一个新版本出来，省得每次手动修改的麻烦。网上找了下教程，发现还是很简单的。maven提供了一种非常快速的创建骨架模板的方式，那就是create-from-project,可以让你直接使用当前项目创建archetype。下面记录一下创建过程，以普通的springboot工程为例，创建自己的archetype:","text":"maven使用起来还是很方便，但默认自带的archetype配置junit版本比较老。每次创建新项目都要手动修改junit版本，所以就想着能不能自己建一个新版本出来，省得每次手动修改的麻烦。网上找了下教程，发现还是很简单的。maven提供了一种非常快速的创建骨架模板的方式，那就是create-from-project,可以让你直接使用当前项目创建archetype。下面记录一下创建过程，以普通的springboot工程为例，创建自己的archetype: 创建普通springboot工程，项目名：Demo创建一个基本的springboot工程，添加依赖，集成swagger2自动生成api文档。springboot+mybatis为主要框架，使用mybatis-generator生成sql映射文件。项目配置不细说，搭建完成后添加示例代码测试OK即可。添加以下achetype插件： 12345&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-archetype-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt;&lt;/plugin&gt; 创建archetype在Demo项目根目录({Demo-root})下执行命令 mvn archetype:create-from-project。注意此时项目{Demo-root}/target/generated-sources/目录下会生成archetype文件夹。到此步可以说已经创建了一个archetype,只是没有安装到仓库，暂时还无法使用 安装到本地仓库命令行cd进入{Demo-root}/target/generated-sources/archetype目录下，此处需要修改以下两处地方： 【A】删除不需要的多余文件修改src/main/resources/META-INF/maven/archetype-metadata.xml文件。其中节点fileSet定义一个文件夹，子节点directory定义文件夹位置，把不需要构建到模板文件夹删除即可。例： 【B】增加私有仓库部署路径，需要让其他人可以使用此模板，必须增加这个配置在当前目录下的pom.xml文件中添加以下配置项 123456789101112&lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;nexus-releases&lt;/id&gt; &lt;name&gt;nexus Releases&lt;/name&gt; &lt;url&gt;http://&#123;ip&#125;:&#123;port&#125;/nexus/content/repositories/releases/&lt;/url&gt; &lt;/repository&gt; &lt;snapshotRepository&gt; &lt;id&gt;nexus-snapshots&lt;/id&gt; &lt;name&gt;nexus Snapshots&lt;/name&gt; &lt;url&gt;http://&#123;ip&#125;:&#123;port&#125;/nexus/content/repositories/snapshots/&lt;/url&gt; &lt;/snapshotRepository&gt;&lt;/distributionManagement&gt; 其中节点&lt;id&gt;需要指定为maven配置文件setting.xml所配置的角色ID，两处ID需要对应。例如： 12345678910111213&lt;!--配置权限,使用默认用户--&gt;&lt;servers&gt; &lt;server&gt; &lt;id&gt;nexus-releases&lt;/id&gt; &lt;username&gt;deployment&lt;/username&gt; &lt;password&gt;deployment123&lt;/password&gt; &lt;/server&gt; &lt;server&gt; &lt;id&gt;nexus-snapshots&lt;/id&gt; &lt;username&gt;deployment&lt;/username&gt; &lt;password&gt;deployment123&lt;/password&gt; &lt;/server&gt;&lt;/servers&gt; 其他内容修改可在src目录下找到相应的模板文件直接修改即可，例如添加默认的readme.md文件内容等。 安装部署在第三步的目录下(target/generated-sources/archetype),执行以下两个命令： mvn install 只能安装到本地仓库，其他人无法使用。 mvn deploy 发布到私服，其他人也可以使用 完成项目模板生成后pom.xml({Demo-root}/target/generated-sources/archetype/pom.xml)中会对artifactId添加后辍-archetype。可以记录此文件的gav直接添加使用模板，或者从Nexus中查找模板坐标使用自定义archetype完成，可以愉快使用了！","categories":[{"name":"technology","slug":"technology","permalink":"http://www.solooo.net/categories/technology/"}],"tags":[{"name":"maven","slug":"maven","permalink":"http://www.solooo.net/tags/maven/"}]},{"title":"Xshell远程连接AWS服务器","slug":"Xshell远程连接AWS服务器","date":"2017-06-20T09:53:14.000Z","updated":"2019-07-17T04:30:48.095Z","comments":true,"path":"2017/06/20/Xshell远程连接AWS服务器/","link":"","permalink":"http://www.solooo.net/2017/06/20/Xshell远程连接AWS服务器/","excerpt":"亚马逊AWS ES服务器有一年的免费使用优惠。注册后创建实例当做远程服务器使用相当方便。比较坑的是注册必须要有信用卡，过程有点麻烦。","text":"亚马逊AWS ES服务器有一年的免费使用优惠。注册后创建实例当做远程服务器使用相当方便。比较坑的是注册必须要有信用卡，过程有点麻烦。 官方给的说明里有SSH连接方式说明： 使用 ssh 命令连接到实例。您可以指定私有密钥 (.pem) 文件和 user_name@public_dns_name。 对于 Amazon Linux，用户名为 ec2-user。对于 RHEL，用户名称是 ec2-user 或 root。对于 Ubuntu，用户名称是 ubuntu 或 root。对于 Centos，用户名称是 centos。对于 Fedora，用户名称是 ec2-user。对于 SUSE，用户名称是 ec2-user 或 root。另外，如果 ec2-user 和 root 无法使用，请与您的 AMI 供应商核实。 教程里介绍的是使用gitBash命令行工具来连接。但个人还是觉得Xshell用起来更方便，以下为配置Xshell登录AWS服务器的步骤，相当简单。 步骤一：新建会话填写名称并选择为SSH，填写 AWS EC 服务器对公IP，端口号默认22，然后修改用户身份验证 步骤二：用户身份验证选择左侧用户身份验证菜单，方法选择为public key, 用户名ubuntu（此处以ubuntu服务器为例），此项可后面步骤再填。然后点击【浏览】导入证书 步骤三：导入证书点击【导入】，选择创建服务器实例时下载的*.pem文件导入，左侧选中此文件点南【确定】，配置完成，可以登录 步骤四：登录登录时选择刚刚新建的会话，如果之前未输入用户名，则会提示输入用户名。点击【确定】，即可登录，如果已配置过用户，无需确认，直接登录成功 登录完成，可以愉快玩耍了！","categories":[{"name":"tool","slug":"tool","permalink":"http://www.solooo.net/categories/tool/"}],"tags":[{"name":"xshell","slug":"xshell","permalink":"http://www.solooo.net/tags/xshell/"}]},{"title":"hexo常用命令","slug":"hexo常用命令","date":"2017-06-20T09:11:08.000Z","updated":"2019-07-17T04:30:48.099Z","comments":true,"path":"2017/06/20/hexo常用命令/","link":"","permalink":"http://www.solooo.net/2017/06/20/hexo常用命令/","excerpt":"","text":"使用hexo搭建博客经常用的命令 1.新建博客 $ hexo new [layout] &lt;title&gt;2.生成静态文件 $ hexo g3.发布博客 $ hexo d4.生成并发布，一步到位 $ hexo g -d","categories":[{"name":"technology","slug":"technology","permalink":"http://www.solooo.net/categories/technology/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.solooo.net/tags/hexo/"}]},{"title":"Zookeeper学习(一)","slug":"Zookeeper学习-一","date":"2017-05-12T14:29:16.000Z","updated":"2019-07-17T04:30:48.099Z","comments":true,"path":"2017/05/12/Zookeeper学习-一/","link":"","permalink":"http://www.solooo.net/2017/05/12/Zookeeper学习-一/","excerpt":"Zookeeper介绍 ZooKeeper is a centralized service for maintaining configuration information, naming, providing distributed synchronization, and providing group services. All of these kinds of services are used in some form or another by distributed applications. Each time they are implemented there is a lot of work that goes into fixing the bugs and race conditions that are inevitable. Because of the difficulty of implementing these kinds of services, applications initially usually skimp on them ,which make them brittle in the presence of change and difficult to manage. Even when done correctly, different implementations of these services lead to management complexity when the applications are deployed. 以上是Zookeeper官网说明，Zookeeper主要提供的服务有：配置管理、名称服务、分布式同步、分组服务。","text":"Zookeeper介绍 ZooKeeper is a centralized service for maintaining configuration information, naming, providing distributed synchronization, and providing group services. All of these kinds of services are used in some form or another by distributed applications. Each time they are implemented there is a lot of work that goes into fixing the bugs and race conditions that are inevitable. Because of the difficulty of implementing these kinds of services, applications initially usually skimp on them ,which make them brittle in the presence of change and difficult to manage. Even when done correctly, different implementations of these services lead to management complexity when the applications are deployed. 以上是Zookeeper官网说明，Zookeeper主要提供的服务有：配置管理、名称服务、分布式同步、分组服务。 使用场景以下是从网上一篇博客引用来的。阅读原文 配置管理在我们的应用中除了代码外，还有一些就是各种配置。比如数据库连接等。一般我们都是使用配置文件的方式，在代码中引入这些配置文件。但是当我们只有一种配置，只有一台服务器，并且不经常修改的时候，使用配置文件是一个很好的做法，但是如果我们配置非常多，有很多服务器都需要这个配置，而且还可能是动态的话使用配置文件就不是个好主意了。这个时候往往需要寻找一种集中管理配置的方法，我们在这个集中的地方修改了配置，所有对这个配置感兴趣的都可以获得变更。比如我们可以把配置放在数据库里，然后所有需要配置的服务都去这个数据库读取配置。但是，因为很多服务的正常运行都非常依赖这个配置，所以需要这个集中提供配置服务的服务具备很高的可靠性。一般我们可以用一个集群来提供这个配置服务，但是用集群提升可靠性，那如何保证配置在集群中的一致性呢？ 这个时候就需要使用一种实现了一致性协议的服务了。Zookeeper就是这种服务，它使用Zab这种一致性协议来提供一致性。现在有很多开源项目使用Zookeeper来维护配置，比如在HBase中，客户端就是连接一个Zookeeper，获得必要的HBase集群的配置信息，然后才可以进一步操作。还有在开源的消息队列Kafka中，也使用Zookeeper来维护broker的信息。在Alibaba开源的SOA框架Dubbo中也广泛的使用Zookeeper管理一些配置来实现服务治理。 名字服务名字服务这个就很好理解了。比如为了通过网络访问一个系统，我们得知道对方的IP地址，但是IP地址对人非常不友好，这个时候我们就需要使用域名来访问。但是计算机是不能是别域名的。怎么办呢？如果我们每台机器里都备有一份域名到IP地址的映射，这个倒是能解决一部分问题，但是如果域名对应的IP发生变化了又该怎么办呢？于是我们有了DNS这个东西。我们只需要访问一个大家熟知的(known)的点，它就会告诉你这个域名对应的IP是什么。在我们的应用中也会存在很多这类问题，特别是在我们的服务特别多的时候，如果我们在本地保存服务的地址的时候将非常不方便，但是如果我们只需要访问一个大家都熟知的访问点，这里提供统一的入口，那么维护起来将方便得多了。 分布式锁其实在第一篇文章中已经介绍了Zookeeper是一个分布式协调服务。这样我们就可以利用Zookeeper来协调多个分布式进程之间的活动。比如在一个分布式环境中，为了提高可靠性，我们的集群的每台服务器上都部署着同样的服务。但是，一件事情如果集群中的每个服务器都进行的话，那相互之间就要协调，编程起来将非常复杂。而如果我们只让一个服务进行操作，那又存在单点。通常还有一种做法就是使用分布式锁，在某个时刻只让一个服务去干活，当这台服务出问题的时候锁释放，立即fail over到另外的服务。这在很多分布式系统中都是这么做，这种设计有一个更好听的名字叫Leader Election(leader选举)。比如HBase的Master就是采用这种机制。但要注意的是分布式锁跟同一个进程的锁还是有区别的，所以使用的时候要比同一个进程里的锁更谨慎的使用。 集群管理在分布式的集群中，经常会由于各种原因，比如硬件故障，软件故障，网络问题，有些节点会进进出出。有新的节点加入进来，也有老的节点退出集群。这个时候，集群中其他机器需要感知到这种变化，然后根据这种变化做出对应的决策。比如我们是一个分布式存储系统，有一个中央控制节点负责存储的分配，当有新的存储进来的时候我们要根据现在集群目前的状态来分配存储节点。这个时候我们就需要动态感知到集群目前的状态。还有，比如一个分布式的SOA架构中，服务是一个集群提供的，当消费者访问某个服务时，就需要采用某种机制发现现在有哪些节点可以提供该服务(这也称之为服务发现，比如Alibaba开源的SOA框架Dubbo就采用了Zookeeper作为服务发现的底层机制)。还有开源的Kafka队列就采用了Zookeeper作为Cosnumer的上下线管理。 安装安装过程非常简单 1.下载文件，此次下载为最新发行版：zookeeper-3.4.10.tar.gz2.解压文件，复制并重命名文件conf/zoo_simple.cfg为zoo.cfg3.修改文件内容： # 心跳间隔时间 tickTime=2000 # 数据目录 dataDir=D:\\\\zookeeper # 服务端口 clientPort=21814.进入bin目录，双击zkServer.cmd启动服务即可 java示例，直接使用Zookeeper API操作： 1234567891011121314151617181920212223242526272829303132333435363738394041public class ZookeeperTest &#123; public static void main(String[] args) &#123; String content = \"this is test测试\"; try &#123; ZooKeeper zooKeeper = new ZooKeeper(\"127.0.0.1:2181\", 3000, null); // 注册 zooKeeper.register(new ZkWatcher(zooKeeper, \"/root\")); // 创建节点 zooKeeper.create(\"/root\", \"root data\".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT); // 设置数据 zooKeeper.setData(\"/root\", content.getBytes(), -1); Stat stat = new Stat(); System.out.println(new String(zooKeeper.getData(\"/root\", false, stat))); zooKeeper.create(\"/root/child\", \"child\".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT); // 节点删除 zooKeeper.delete(\"/root/child\", -1); zooKeeper.delete(\"/root\", -1); &#125; catch (IOException | InterruptedException | KeeperException e) &#123; e.printStackTrace(); &#125; &#125; public static class ZkWatcher implements Watcher &#123; private ZooKeeper zooKeeper; private String path; public ZkWatcher(ZooKeeper zooKeeper, String path) &#123; this.zooKeeper = zooKeeper; this.path = path; &#125; @Override public void process(WatchedEvent watchedEvent) &#123; System.out.println(\"Watcher: \" + watchedEvent.getType()); &#125; &#125;&#125; 使用ZkClient操作Zookeeper,此包封装了对zk的一些常用操作 Maven包引用： 12345&lt;dependency&gt; &lt;groupId&gt;com.101tec&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.10&lt;/version&gt;&lt;/dependency&gt; 12345678910111213141516171819202122232425262728293031public class ZkClientTest &#123; public static final String PATH = \"/zkClient\"; public static void main(String[] args) &#123; ZkClient client = new ZkClient(\"127.0.0.1:2181\"); client.subscribeDataChanges(PATH, new IZkDataListener() &#123; @Override public void handleDataChange(String s, Object o) throws Exception &#123; System.out.println(\"handleDataChange s: \" + s + \" data: \" + o); &#125; @Override public void handleDataDeleted(String s) throws Exception &#123; System.out.println(\"handleDataDeleted s:\" + s); &#125; &#125;); client.create(PATH, \"school\", CreateMode.PERSISTENT); client.writeData(PATH, \"城中\"); System.out.println(client.readData(PATH)); client.create(PATH + \"/child\", \"child\", CreateMode.PERSISTENT); System.out.println(client.getChildren(PATH)); client.writeData(PATH + \"/child\", \"高三三班\"); System.out.println(client.readData(PATH + \"/child\")); client.delete(PATH + \"/child\"); client.delete(PATH); &#125;&#125; 以上是对Zookeeper的基本操作，具体的使用还在学习中。 参考博客：http://www.cnblogs.com/powercto/p/6844798.html","categories":[{"name":"technology","slug":"technology","permalink":"http://www.solooo.net/categories/technology/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.solooo.net/tags/java/"},{"name":"zookeeper","slug":"zookeeper","permalink":"http://www.solooo.net/tags/zookeeper/"}]},{"title":"Euler-4-Largest-palindrome-product","slug":"Euler-4-Largest-palindrome-product","date":"2017-03-17T05:46:01.000Z","updated":"2019-07-17T04:30:48.095Z","comments":true,"path":"2017/03/17/Euler-4-Largest-palindrome-product/","link":"","permalink":"http://www.solooo.net/2017/03/17/Euler-4-Largest-palindrome-product/","excerpt":"Problem 4: Largest palindrome productA palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99. Find the largest palindrome made from the product of two 3-digit numbers.","text":"Problem 4: Largest palindrome productA palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99. Find the largest palindrome made from the product of two 3-digit numbers. Answer:java code: 1234567891011121314151617181920212223242526272829303132public class Palindrome &#123; /* Largest palindrome product Problem 4 A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99. Find the largest palindrome made from the product of two 3-digit numbers. */ public static void main(String[] args) &#123; long time = System.currentTimeMillis(); int n = 3; int a = (int) (Math.pow(10, n) -1); int max = 0; for (int i = a; i &gt; 0; i--) &#123; for (int j = a; j &gt; 0; j--) &#123; int product = i * j; String s = String.valueOf(product); String[] split = s.split(\"\"); String str = \"\"; for (int m = split.length - 1; m &gt;= 0; m--) &#123; str += split[m]; &#125; if (s.equals(str) &amp;&amp; Integer.parseInt(s) &gt; max) &#123; max = Integer.parseInt(s); &#125; &#125; &#125; System.out.printf(\"Max Palindrome %d, cost %d ms\", max, System.currentTimeMillis() - time); &#125;&#125;","categories":[{"name":"euler","slug":"euler","permalink":"http://www.solooo.net/categories/euler/"}],"tags":[{"name":"Euler","slug":"Euler","permalink":"http://www.solooo.net/tags/Euler/"}]},{"title":"SQL语法分解","slug":"SQL语法分解","date":"2017-03-14T14:04:39.000Z","updated":"2019-07-17T04:30:48.095Z","comments":true,"path":"2017/03/14/SQL语法分解/","link":"","permalink":"http://www.solooo.net/2017/03/14/SQL语法分解/","excerpt":"最近项目中需要做一个类似SQL编辑器的功能，与PL/SQL类似，用户输入不同的sql语句，后台启用jdbc去执行并返回结果。 起初想的比较简单，用户输入一条语句，提交并执行。实现起来也很简单。但是一想，如果用户输入多个SQL怎么办？于是以分号对sql进行分割，批量提交到后台执行。结果还是有问题，就是不能保证所有的语句都是select，如果是update/insert怎么办？又或者是create/drop等DML语言怎么办？","text":"最近项目中需要做一个类似SQL编辑器的功能，与PL/SQL类似，用户输入不同的sql语句，后台启用jdbc去执行并返回结果。 起初想的比较简单，用户输入一条语句，提交并执行。实现起来也很简单。但是一想，如果用户输入多个SQL怎么办？于是以分号对sql进行分割，批量提交到后台执行。结果还是有问题，就是不能保证所有的语句都是select，如果是update/insert怎么办？又或者是create/drop等DML语言怎么办？ 第一套方案是先以分号对sql进行分割，然后对分割后的语句，逐条使用jsqlparser进行解析，识别出select与其他非select语句。然后对select语句进行单独处理，其他非select语句，直接执行不返回结果。结果勉强能够实现简单的功能。对于select语句由于使用了远程调用的方式，一次性返回结果不能太大，需要对查询语句进行分页处理，所以自己拼装了count语句，与分页查询，可以正常返回结果。 后来又有新需求，需要在编辑器里执行存储过程的创建与执行。。。。存储过程中有分号，所以用分号分割不可行，而jsqlparser无法识别存储过程语法，无奈再次更换方案，首先要解决的是语法怎么分割的问题，对于一次性输入完成的sql来说，不存在什么问题，但在执行存储过程之前需要进行相应的设置才行，而设置需要在同一个连接中进行，所以sql需要批量同时执行，也就是一次要写多条sql，而且要正确的分割出不同的可执行的完整sql。思前想后没有什么好的解决办法，最后只能以最基本的语法，按开始与结束的字符串进行分割。 按照oracle语法分析，普通的select或insert/update/delete/create table等都是一整条完整的语句，并且以分号结束，中间不会再包含分号，所以，如果以这几个关键字开头的语句，可以直接查找分号进行分割；麻烦的问题在于处理存储过程，其中会有分号，也有其他的操作语句，但会以end字符结束，所以，分析字符串如果有创建并且是创建存储过程，则以end做为结束符时行分割，按此思路进行代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108/** * 分割sql */public class SqlParserUtil &#123; private static final Pattern pattern = Pattern.compile(\"[^A-Za-z]\"); private static final List&lt;String&gt; sqlKeys = new ArrayList&lt;&gt;(); static &#123; sqlKeys.add(\"create\"); sqlKeys.add(\"select\"); sqlKeys.add(\"alter\"); sqlKeys.add(\"insert\"); sqlKeys.add(\"update\"); sqlKeys.add(\"drop\"); sqlKeys.add(\"merge\"); sqlKeys.add(\"truncate\"); sqlKeys.add(\"use\"); sqlKeys.add(\"set\"); sqlKeys.add(\"begin\"); sqlKeys.add(\"declare\"); &#125; /** * 找到语句开始字符，根据语句类型判断结束字符串，遍历所有单词，直至找到结束点或语句结尾，以此分割sql * @param str * @return * @throws Exception */ public static List&lt;String&gt; parserSql(String str) throws Exception &#123; String sql = str.toLowerCase().replaceAll(\"\\\\s+\", \" \").replaceAll(\";\", \" ; \").trim(); String[] strs = sql.split(\"\\\\s+\"); StringBuilder sb = new StringBuilder(); List&lt;String&gt; sqlList = new ArrayList&lt;&gt;(); String startStr = null, endStr = null, preStr = null; int stack = 0; for (int i = 0; i &lt; strs.length; i++) &#123; boolean clearPreStr = false; // 是否将 preStr 设为null String s = strs[i]; if (sb.length() == 0 &amp;&amp; pattern.matcher(s).find()) &#123; continue; &#125; sb.append(s).append(\" \"); if (startStr == null &amp;&amp; !sqlKeys.contains(s)) &#123; int len = strs.length; String errorSql = \"\"; while (++i &lt; len) &#123; errorSql += strs[i]; &#125; throw new Exception(\"语法错误\" + errorSql); &#125; if (startStr == null &amp;&amp; sqlKeys.contains(s)) &#123; startStr = s; endStr = \"begin\".equals(s) || \"declare\".equals(s) ? \"end\" : \";\"; // begin开关语句以end结尾 stack++; &#125; else if (\"create\".equals(startStr) &amp;&amp; (\"procedure\".equals(s) || \"package\".equals(s)) ) &#123; // 创建存储过程或包时，结束符以\"end\"终止 String createStatement = sb.toString().trim(); if ((\"create or replace \" + s).equals(createStatement) || (\"create \" + s).equals(createStatement)) &#123; endStr = \"end\"; if (\"procedure\".equals(s)) &#123; stack--; &#125; &#125; &#125; else if (s.equals(\"begin\") || (!\"end\".equals(preStr) &amp;&amp; \"loop\".equals(s))) &#123; // begin/loop 关键字结束符都为 end, 所以需要+1 stack++; &#125; else if (\"transaction\".equals(s) &amp;&amp; \"begin\".equals(preStr)) &#123; stack--; &#125; else if (s.equals(endStr) || i == strs.length - 1) &#123; stack--; if (stack == 0) &#123; startStr = null; clearPreStr = true; if (!\";\".equals(endStr) &amp;&amp; !\";\".equals(s)) &#123; sb.append(\";\"); &#125; sqlList.add(sb.toString()); sb.setLength(0); &#125; &#125; // 设置上一个关键字内容 if (clearPreStr) &#123; preStr = null; &#125; else &#123; preStr = s; &#125; &#125; return sqlList; &#125; public static void main(String[] args) throws Exception &#123; String sql = \"select * from tt; \\n select * from t2\"; List&lt;String&gt; sqlList = SqlParserUtil.parserSql(sql); for (String s : sqlList) &#123; System.out.println(s); &#125; &#125;&#125; 以上方法，基本可以实现oracle语法各种查询，包括存储过程的分割。以后有什么更好的思路再进行更新吧，暂且如此。","categories":[{"name":"technology","slug":"technology","permalink":"http://www.solooo.net/categories/technology/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.solooo.net/tags/java/"},{"name":"sql","slug":"sql","permalink":"http://www.solooo.net/tags/sql/"}]},{"title":"Euler 3 Largest prime factor","slug":"Euler-3-Largest-prime-factor","date":"2017-03-14T05:41:09.000Z","updated":"2019-07-17T04:30:48.095Z","comments":true,"path":"2017/03/14/Euler-3-Largest-prime-factor/","link":"","permalink":"http://www.solooo.net/2017/03/14/Euler-3-Largest-prime-factor/","excerpt":"Problem 3: Largest prime factorThe prime factors of 13195 are 5, 7, 13 and 29. What is the largest prime factor of the number 600851475143 ?","text":"Problem 3: Largest prime factorThe prime factors of 13195 are 5, 7, 13 and 29. What is the largest prime factor of the number 600851475143 ? Answer:java code: 123456789101112131415161718192021public class PrimeFactor &#123; private static Long maxPrimeFactor(Long n) &#123; if (n &lt; 2) &#123; return n; &#125; Long i = 2L; while (n &gt; i) &#123; if (n%i == 0) &#123; n = n/i; &#125; i++; &#125; return i; &#125; public static void main(String[] args) &#123; Long n = 6008514751430L; System.out.println(maxPrimeFactor(n)); &#125;&#125;","categories":[{"name":"euler","slug":"euler","permalink":"http://www.solooo.net/categories/euler/"}],"tags":[{"name":"Euler","slug":"Euler","permalink":"http://www.solooo.net/tags/Euler/"}]},{"title":"POI 导出 Excel 自动列宽","slug":"POI-导出-Excel-自动列宽","date":"2017-02-09T04:33:15.000Z","updated":"2019-07-17T04:30:48.095Z","comments":true,"path":"2017/02/09/POI-导出-Excel-自动列宽/","link":"","permalink":"http://www.solooo.net/2017/02/09/POI-导出-Excel-自动列宽/","excerpt":"123Sheet sheet = workbook.getSheetAt(0);sheet.autoSizeColumn(0); //adjust width of the first columnsheet.autoSizeColumn(1); //adjust width of the second column For SXSSFWorkbooks only, because the random access window is likely to exclude most of the rows in the worksheet, which are needed for computing the best-fit width of a column, the columns must be tracked for auto-sizing prior to flushing any rows.","text":"123Sheet sheet = workbook.getSheetAt(0);sheet.autoSizeColumn(0); //adjust width of the first columnsheet.autoSizeColumn(1); //adjust width of the second column For SXSSFWorkbooks only, because the random access window is likely to exclude most of the rows in the worksheet, which are needed for computing the best-fit width of a column, the columns must be tracked for auto-sizing prior to flushing any rows. 1234567891011121314151617181920212223SXSSFWorkbook workbook = new SXSSFWorkbook();SXSSFSheet sheet = workbook.createSheet();sheet.trackColumnForAutoSizing(0);sheet.trackColumnForAutoSizing(1);// If you have a Collection of column indices, see SXSSFSheet#trackColumnForAutoSizing(Collection&lt;Integer&gt;)// or roll your own for-loop.// Alternatively, use SXSSFSheet#trackAllColumnsForAutoSizing() if the columns that will be auto-sized aren&apos;t// known in advance or you are upgrading existing code and are trying to minimize changes. Keep in mind// that tracking all columns will require more memory and CPU cycles, as the best-fit width is calculated// on all tracked columns on every row that is flushed.// create some cellsfor (int r=0; r &lt; 10; r++) &#123; Row row = sheet.createRow(r); for (int c; c &lt; 10; c++) &#123; Cell cell = row.createCell(c); cell.setCellValue(&quot;Cell &quot; + c.getAddress().formatAsString()); &#125;&#125;// Auto-size the columns.sheet.autoSizeColumn(0);sheet.autoSizeColumn(1); Note, that Sheet#autoSizeColumn() does not evaluate formula cells, the width of formula cells is calculated based on the cached formula result. If your workbook has many formulas then it is a good idea to evaluate them before auto-sizing. 来源： http://poi.apache.org/spreadsheet/quick-guide.html","categories":[{"name":"technology","slug":"technology","permalink":"http://www.solooo.net/categories/technology/"}],"tags":[{"name":"poi","slug":"poi","permalink":"http://www.solooo.net/tags/poi/"},{"name":"java","slug":"java","permalink":"http://www.solooo.net/tags/java/"}]},{"title":"Linux JDK 环境变量","slug":"Linux-JDK-环境变量","date":"2017-02-06T03:06:50.000Z","updated":"2019-07-17T04:30:48.095Z","comments":true,"path":"2017/02/06/Linux-JDK-环境变量/","link":"","permalink":"http://www.solooo.net/2017/02/06/Linux-JDK-环境变量/","excerpt":"系统版本Ubuntu16.04.1 编辑文件 /etc/profile","text":"系统版本Ubuntu16.04.1 编辑文件 /etc/profile 文件末尾添加1234#set jdk environmentexport JAVA_HOME=/usr/lib/jvm/jdk1.7.0_21export CLASSPATH=.:$JAVA_HOME/lib:$JAVA_HOME/jre/lib:$CLASSPATHexport PATH=$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$PATH 使文件生效 source /etc/profile OK!","categories":[{"name":"technology","slug":"technology","permalink":"http://www.solooo.net/categories/technology/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.solooo.net/tags/Linux/"},{"name":"JDK","slug":"JDK","permalink":"http://www.solooo.net/tags/JDK/"}]}]}